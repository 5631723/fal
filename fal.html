
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>fal.ai API Explorer</title>
  <link rel="stylesheet" href="/viewer.min.css" />
  <script src="/viewer.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Configure Tailwind dark mode
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            'dark-bg': '#050505',  // æ›´æš—çš„èƒŒæ™¯è‰²
            'dark-card': '#0a0a0a', // æ›´æš—çš„å¡ç‰‡èƒŒæ™¯
            'dark-border': '#1a1a1a', // æ›´æš—çš„è¾¹æ¡†
          }
        }
      }
    }
  </script>
  <style>
    /* Custom styles */
    .image-container {
      position: relative;
      overflow: hidden;
      border-radius: 0.5rem;
      transition: all 0.3s ease;
      cursor: pointer;
    }
    .image-container:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.1);
    }

    .dark .image-container:hover {
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.4);
    }

    .light-glass {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .dark-glass {
      background: rgba(0, 0, 0, 0.6); /* å¢åŠ ä¸é€æ˜åº¦ä½¿èƒŒæ™¯æ›´æš— */
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.03);
    }

    .loading-animation {
      display: inline-block;
      width: 40px;
      height: 40px;
      border: 3px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .fade-in {
      animation: fadeIn 0.5s ease-in;
    }

    @keyframes fadeIn {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    /* Added slide-in animations */
    .slide-in-right {
      animation: slideInRight 0.5s ease-out;
    }

    @keyframes slideInRight {
      0% {
        opacity: 0;
        transform: translateX(30px);
      }
      100% {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .slide-in-up {
      animation: slideInUp 0.6s ease-out;
    }

    @keyframes slideInUp {
      0% {
        opacity: 0;
        transform: translateY(20px);
      }
      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* History image styles */
    .history-image {
      width: 80px;
      height: 80px;
      object-fit: cover;
      border-radius: 0.375rem;
      transition: all 0.3s;
    }

    .history-image:hover {
      transform: scale(1.05);
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    /* Delete button modern flat style */
    .history-item .delete-btn {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 20px;
      height: 20px;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.2s;
      cursor: pointer;
    }
    .history-item:hover .delete-btn {
      opacity: 1;
    }
    .history-item .delete-btn:hover {
      background: rgba(0, 0, 0, 0.8);
    }

    /* Scrollbar styles */
    .custom-scrollbar::-webkit-scrollbar {
      height: 9px;
    }

    .light .custom-scrollbar::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 10px;
    }

    .light .custom-scrollbar::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.5);
      border-radius: 10px;
    }

    .light .custom-scrollbar::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.7);
    }

    .dark .custom-scrollbar::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
    }

    .dark .custom-scrollbar::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      border: 2px solid rgba(0, 0, 0, 0.3); /* æ·»åŠ è¾¹æ¡†å¢åŠ å¯¹æ¯”åº¦ */
    }

    .dark .custom-scrollbar::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.35);
    }

    /* Log styles */
    .logs-container {
      height: 120px;
      font-family: monospace;
    }

    .log-entry {
      margin-bottom: 2px;
      line-height: 1.3;
      word-wrap: break-word;
      overflow-wrap: break-word;
      white-space: pre-wrap;
      max-width: 100%;
    }

    .log-info { color: #a3e635; } /* Lime green for info */
    .log-warn { color: #fbbf24; } /* Amber for warning */
    .log-error { color: #f87171; } /* Red for error */

    /* Theme toggle button */
    .theme-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 30px;
    }

    .theme-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 30px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1) inset;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    input:checked + .slider {
      background-color: #6366f1; /* Indigo */
    }

    input:focus + .slider {
      box-shadow: 0 0 1px #6366f1;
    }

    input:checked + .slider:before {
      transform: translateX(30px);
    }

    .slider:after {
      content: 'â˜€ï¸'; /* Sun icon */
      color: #fff;
      display: block;
      position: absolute;
      transform: translate(-50%,-50%);
      top: 50%;
      left: 30%;
      font-size: 12px;
      transition: .3s ease-in-out;
    }

    input:checked + .slider:after {
      content: 'ğŸŒ™'; /* Moon icon */
      left: 70%;
    }

    /* Slider container styles */
    .slider-container {
      width: 100%;
      display: flex;
      flex-direction: column;
    }

    .slider-value {
      margin-top: 4px;
      font-size: 0.875rem; /* text-sm */
      text-align: right;
    }

    /* Custom range input styles */
    input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 6px;
      border-radius: 5px;
      background: #d3d3d3; /* Light gray */
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #6366f1; /* Indigo */
      cursor: pointer;
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
      transition: all 0.2s ease;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.1);
      box-shadow: 0 0 8px rgba(99,102,241,0.5); /* Indigo shadow */
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #6366f1; /* Indigo */
      cursor: pointer;
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
      transition: all 0.2s ease;
    }

    input[type="range"]::-moz-range-thumb:hover {
      transform: scale(1.1);
    }

    .dark input[type="range"] {
      background: #2d3748; /* Gray-700 */
    }

    /* Toggle switch styles */
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 48px;
      height: 24px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 24px;
      box-shadow: 0 0 3px rgba(0,0,0,0.1) inset;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }

    input:checked + .toggle-slider {
      background-color: #6366f1; /* Indigo */
    }

    input:checked + .toggle-slider:before {
      transform: translateX(24px);
    }

    /* Button hover effect */
    .btn-hover-effect {
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .btn-hover-effect:after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 5px;
      height: 5px;
      background: rgba(255, 255, 255, 0.3);
      opacity: 0;
      border-radius: 100%;
      transform: scale(1, 1) translate(-50%);
      transform-origin: 50% 50%;
    }

    .btn-hover-effect:hover:after {
      animation: ripple 1s ease-out;
    }

    @keyframes ripple {
      0% {
        transform: scale(0, 0);
        opacity: 0.5;
      }
      20% {
        transform: scale(25, 25);
        opacity: 0.3;
      }
      100% {
        opacity: 0;
        transform: scale(40, 40);
      }
    }

    /* Card hover effect */
    .card-hover {
      transition: all 0.3s ease;
    }

    .card-hover:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    }

    .dark .card-hover:hover {
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
    }

    /* Input focus effect */
    .input-focus-effect {
      transition: all 0.3s ease;
    }

    .input-focus-effect:focus {
      transform: scale(1.02);
    }

    /* Dark mode specific styles */
    .dark body {
      background-color: #030303; /* æ›´æš—çš„ç°è‰² */
    }

    .dark .card-bg {
      background-color: #080808; /* è¿‘é»‘è‰² */
    }

    .dark .border-color {
      border-color: #1a1a1a; /* æ›´æš—çš„è¾¹æ¡† */
    }

    /* Custom model input transition */
    #customModelInput {
      transition: opacity 0.3s ease, max-height 0.3s ease, margin-top 0.3s ease;
      max-height: 0;
      opacity: 0;
      overflow: hidden;
      margin-top: 0;
    }

    #customModelInput.visible {
      max-height: 100px; /* Sufficient height */
      opacity: 1;
      margin-top: 0.75rem; /* mt-3 */
    }

    /* æ–°å¢ï¼šæ ¹æ® body.light ä¸ body.dark è®¾ç½®èƒŒæ™¯ */
    body.light {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    body.dark {
      background: linear-gradient(135deg, #121212 0%, #000000 100%);
    }
  </style>
  <script defer src="https://umami.sxjeru.top/script.js" data-website-id="5762b24a-8944-40b3-9550-359e500e4d19"></script>
  
</head>
<body class="min-h-screen text-white font-sans light transition-colors duration-500">

  <div class="container mx-auto px-3 py-5">
    <header class="flex flex-col md:flex-row justify-between items-center mb-8 slide-in-up">
      <div class="text-center md:text-left mb-4 md:mb-0">
        <h1 class="text-4xl font-bold mb-2">fal.ai API Explorer</h1>
        <p class="text-lg opacity-80">AI é©±åŠ¨çš„æ–‡æœ¬è½¬å›¾åƒæœåŠ¡</p>
      </div>

      <div class="flex items-center gap-2">
        <span class="text-sm">äº®è‰²</span>
        <label class="theme-switch">
          <input type="checkbox" id="themeToggle">
          <span class="slider"></span>
        </label>
        <span class="text-sm">æš—è‰²</span>
      </div>
    </header>

    <div class="max-w-3xl mx-auto light-glass dark:dark-glass p-4 rounded-xl mb-6 card-hover slide-in-up" style="animation-delay: 0.1s;">
      <h2 class="text-xl font-semibold mb-3">ğŸ”‘ API è®¤è¯</h2>
      <div class="flex flex-col md:flex-row gap-3">
        <input
          type="password"
          id="apiKeyInput"
          class="flex-grow p-2 rounded-lg text-gray-800 dark:text-gray-200 dark:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-purple-400 input-focus-effect"
          placeholder="è¾“å…¥ä½ çš„ FAL_KEY"
        />
        <button
          id="saveApiKey"
          class="bg-purple-600 hover:bg-purple-700 text-white py-2 px-5 rounded-lg transition-colors btn-hover-effect"
        >
          ä¿å­˜å¯†é’¥
        </button>
      </div>
      <div id="keyStatus" class="mt-2 text-sm"></div>
      <p class="text-xs mt-1 opacity-75">API å¯†é’¥ä»…ä¿å­˜åœ¨å½“å‰æµè§ˆå™¨ä¼šè¯ä¸­ï¼Œä¸ä¼šå‘é€åˆ°é™¤ fal.ai ä»¥å¤–çš„ä»»ä½•æœåŠ¡å™¨ã€‚</p>
    </div>

    <div class="max-w-6xl mx-auto light-glass dark:dark-glass p-4 rounded-xl mb-6 card-hover slide-in-up" style="animation-delay: 0.2s;">
      <div class="flex justify-between items-center mb-3">
        <h2 class="text-xl font-semibold">ğŸ•’ å†å²è®°å½•</h2>
        <button
          id="clearHistoryBtn"
          class="text-sm bg-red-500/40 hover:bg-red-500/60 px-3 py-1 rounded-full transition-colors btn-hover-effect"
        >
          æ¸…ç©ºå†å²
        </button>
      </div>
      <div id="historyRow" class="flex gap-3 overflow-x-auto pb-2 custom-scrollbar">
        <div class="text-center text-gray-300 dark:text-gray-500 text-sm italic w-full py-6">æš‚æ— å†å²å›¾ç‰‡</div>
      </div>
    </div>

    <div class="max-w-6xl mx-auto light-glass dark:dark-glass p-5 rounded-xl mb-6 card-hover slide-in-up" style="animation-delay: 0.3s;">
      <h2 class="text-xl font-semibold mb-4">âœ¨ ç”Ÿæˆå›¾åƒ</h2>

      <div class="flex flex-col md:flex-row gap-5">
        <div class="flex-1">
          <form id="generationForm" class="space-y-4">
            <div>
              <label for="prompt" class="block text-base mb-1">æç¤ºè¯</label>
              <textarea
                id="prompt"
                rows="3"
                class="w-full p-2 rounded-lg text-gray-800 dark:text-gray-200 dark:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-purple-400 input-focus-effect"
                placeholder="æè¿°ä½ æƒ³ç”Ÿæˆçš„å›¾åƒ..."
              ></textarea>
            </div>

            <div>
              <label for="model" class="block text-base mb-1">æ¨¡å‹</label>
              <select
                id="model"
                class="w-full p-2 rounded-lg text-gray-800 dark:text-gray-200 dark:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-purple-400"
              >
                <option value="fal-ai/flux-pro/new">FLUX.1 - é«˜è´¨é‡é€šç”¨æ¨¡å‹</option>
                <option value="fal-ai/flux-pro/v1.1">FLUX.1.1 Pro - æ›´å¿«æ›´å¥½çš„é€šç”¨æ¨¡å‹</option>
                <option value="fal-ai/flux-pro/v1.1-ultra">FLUX.1.1 Ultra - æ›´é«˜ç»†èŠ‚çº¹ç†</option>
                <option value="fal-ai/recraft-v3">Recraft V3 - é€‚åˆé£æ ¼åŒ–å›¾åƒ</option>
                <option value="fal-ai/stable-diffusion-v35-large">SD 3.5 Large - é€‚åˆå¤æ‚åœºæ™¯</option>
                <option value="fal-ai/hidream-i1-dev">HiDream-I1 dev</option>
                <option value="fal-ai/ideogram/v2">Ideogram V2 - æ–‡å­—å’Œæ ‡å¿—è®¾è®¡</option>
                <option value="fal-ai/imagen3">Imagen 3 - Googleé«˜æ¸…å›¾åƒæ¨¡å‹</option>
                <option value="custom">è‡ªå®šä¹‰æ¨¡å‹...</option> </select>
              <input
                type="text"
                id="customModelInput"
                class="w-full p-2 rounded-lg text-gray-800 dark:text-gray-200 dark:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-purple-400 input-focus-effect"
                placeholder="è¾“å…¥è‡ªå®šä¹‰æ¨¡å‹å€¼ï¼Œä¾‹å¦‚: fal-ai/recraft-v3"
              />
            </div>

            <div>
              <button
                type="submit"
                id="generateBtn"
                class="w-full bg-purple-600 hover:bg-purple-700 py-3 px-6 rounded-lg font-bold transition-all duration-300 transform hover:scale-[1.02] btn-hover-effect"
              >
                ç”Ÿæˆå›¾åƒ
              </button>
            </div>

            <div>
              <div class="flex items-center gap-2 mb-2">
                <h3 class="text-base font-medium">é«˜çº§é€‰é¡¹</h3>
                <button
                  type="button"
                  id="toggleAdvanced"
                  class="text-sm bgç™½/20 dark:bgç™½/10 hover:bgç™½/30 dark:hover:bgç™½/20 px-2 py-1 rounded-full transition-colors"
                >
                  æ˜¾ç¤º
                </button>
              </div>

              <div id="advancedOptions" class="hidden space-y-3 p-3 bg-white/10 dark:bg-black/40 rounded-lg">
                <div>
                  <label for="seed" class="block mb-1">éšæœºç§å­</label>
                  <input
                    type="number"
                    id="seed"
                    class="w-full p-2 rounded-lg text-gray-800 dark:text-gray-200 dark:bg-gray-800"
                    placeholder="ç•™ç©ºåˆ™éšæœºç”Ÿæˆ"
                  />
                </div>

                <div>
                  <label for="imageSize" class="block mb-1">å›¾åƒå°ºå¯¸</label>
                  <select
                    id="imageSize"
                    class="w-full p-2 rounded-lg text-gray-800 dark:text-gray-200 dark:bg-gray-800"
                  >
                    <option value="square_hd">æ­£æ–¹å½¢é«˜æ¸…</option>
                    <option value="portrait_16_9">ç«–å‘ 16:9</option>
                    <option value="landscape_16_9">æ¨ªå‘ 16:9</option>
                    <option value="landscape_4_3">æ¨ªå‘ 4:3</option>
                    <option value="custom">è‡ªå®šä¹‰å°ºå¯¸</option>
                  </select>
                </div>

                <div id="customSizeContainer" class="hidden">
                  <div class="flex flex-col md:flex-row gap-3">
                    <div class="flex-1">
                      <label for="customWidth" class="block mb-1">è‡ªå®šä¹‰å®½åº¦</label>
                      <input
                        type="number"
                        id="customWidth"
                        class="w-full p-2 rounded-lg text-gray-800 dark:text-gray-200 dark:bg-gray-800"
                        placeholder="å®½åº¦ï¼ˆåƒç´ ï¼‰"
                        value="512"
                        min="256"
                        max="2048"
                      />
                    </div>
                    <div class="flex-1">
                      <label for="customHeight" class="block mb-1">è‡ªå®šä¹‰é«˜åº¦</label>
                      <input
                        type="number"
                        id="customHeight"
                        class="w-full p-2 rounded-lg text-gray-800 dark:text-gray-200 dark:bg-gray-800"
                        placeholder="é«˜åº¦ï¼ˆåƒç´ ï¼‰"
                        value="512"
                        min="256"
                        max="2048"
                      />
                    </div>
                  </div>
                </div>

                <div>
                  <label for="numImages" class="block mb-1">å›¾åƒæ•°é‡</label>
                  <input
                    type="number"
                    id="numImages"
                    class="w-full p-2 rounded-lg text-gray-800 dark:text-gray-200 dark:bg-gray-800"
                    value="1"
                    min="1"
                    max="4"
                  />
                </div>

                <div class="transition-all duration-300">
                  <label for="numInferenceSteps" class="block mb-1">æ¨ç†æ­¥æ•°ï¼ˆé»˜è®¤: 28ï¼‰</label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="numInferenceSteps"
                      min="1"
                      max="50"
                      value="28"
                    />
                    <div class="slider-value" id="numInferenceStepsValue">28</div>
                  </div>
                </div>

                <div class="transition-all duration-300">
                  <label for="guidanceScale" class="block mb-1">å¼•å¯¼å°ºåº¦ CFGï¼ˆé»˜è®¤: 3.5ï¼‰</label>
                  <div class="slider-container">
                    <input
                      type="range"
                      id="guidanceScale"
                      min="1"
                      max="20"
                      step="0.1"
                      value="3.5"
                    />
                    <div class="slider-value" id="guidanceScaleValue">3.5</div>
                  </div>
                </div>

                <div class="flex items-center justify-between">
                  <label for="rawMode" class="block">è‡ªç„¶æ¨¡å¼</label>
                  <label class="toggle-switch">
                    <input type="checkbox" id="rawMode">
                    <span class="toggle-slider"></span>
                  </label>
                </div>
                <p class="text-xs opacity-75">ç”Ÿæˆæ›´å°‘å¤„ç†ã€æ›´è‡ªç„¶çš„å›¾åƒæ•ˆæœã€‚</p>

                <div class="flex items-center justify-between">
                  <label for="syncMode" class="block">åŒæ­¥æ¨¡å¼</label>
                  <label class="toggle-switch">
                    <input type="checkbox" id="syncMode" checked>
                    <span class="toggle-slider"></span>
                  </label>
                </div>
                <p class="text-xs opacity-75">åŒæ­¥æ¨¡å¼ä¼šç­‰å¾…å›¾åƒç”Ÿæˆå®Œæˆåå†è¿”å›ç»“æœï¼Œè¿™ä¼šå¢åŠ å»¶è¿Ÿä½†å¯ä»¥ç›´æ¥è·å–å›¾åƒã€‚</p>

                <div class="flex items-center justify-between">
                  <label for="enableSafetyChecker" class="block">å¯ç”¨å®‰å…¨æ£€æŸ¥å™¨</label>
                  <label class="toggle-switch">
                    <input type="checkbox" id="enableSafetyChecker">
                    <span class="toggle-slider"></span>
                  </label>
                </div>
                <p class="text-xs opacity-75">å®‰å…¨æ£€æŸ¥å™¨ä¼šè¿‡æ»¤æ‰å¯èƒ½å«æœ‰ä¸é€‚å®œå†…å®¹çš„å›¾åƒã€‚</p>
              </div>
            </div>
          </form>
        </div>

        <div class="flex-1">
          <div class="bg-white/10 dark:bg-black/40 rounded-lg h-full p-4">
            <h3 class="text-lg mb-3">ç»“æœ</h3>
            <div id="loading" class="hidden flex justify-center items-center py-12">
              <div class="text-center">
                <div class="loading-animation mb-3"></div>
                <p id="loadingStatus" class="text-base">æ­£åœ¨å¤„ç†è¯·æ±‚...</p>
              </div>
            </div>
            <div id="results" class="grid grid-cols-1 md:grid-cols-2 gap-3"></div>
            <div id="errorMessage" class="hidden text-red-300 p-3 bg-red-900/30 rounded-lg mt-3"></div>
          </div>
        </div>
      </div>
    </div>

    <div id="logsContainer" class="max-w-6xl mx-auto light-glass dark:dark-glass p-4 rounded-xl mb-6 hidden slide-in-up" style="animation-delay: 0.4s;">
      <h2 class="text-xl font-semibold mb-3">ğŸ“‹ æ—¥å¿—</h2>
      <div id="logsContent" class="logs-container bg-black/20 p-3 rounded-lg overflow-y-auto"></div>
    </div>
    <footer class="mt-12 text-center text-sm opacity-75 slide-in-up" style="animation-delay: 0.5s;">
      
  
    </footer>
  </div>

  <script>
    // Global variables
    let historyViewer = null;
    let resultsViewer = null;

    // --- MOVED: Log functions to global scope ---
    /**
     * Adds a log entry to the logs container.
     * @param {string} message - The log message.
     * @param {'info'|'warn'|'error'} [level='info'] - The log level.
     */
    function addLog(message, level = 'info') {
        const logsContent = document.getElementById('logsContent');
        // Ensure logsContent exists before proceeding
        if (!logsContent) {
            console.warn("Log container not found yet.");
            return;
        }
        const logEntry = document.createElement('div');
        logEntry.className = `log-entry log-${level}`;
        logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logsContent.appendChild(logEntry);
        // Scroll to the bottom
        logsContent.scrollTop = logsContent.scrollHeight;
    }

    /**
     * Clears all entries from the logs container.
     */
    function clearLogs() {
        const logsContent = document.getElementById('logsContent');
         // Ensure logsContent exists before proceeding
        if (logsContent) {
            logsContent.innerHTML = '';
        }
    }
    // --- END MOVED ---


    // Check if Viewer library is loaded correctly
    function isViewerLoaded() {
      return typeof Viewer === 'function';
    }

    // Initialize the application
    document.addEventListener('DOMContentLoaded', () => {
      console.log("DOM loaded, initializing application...");

      // Initialize theme
      initTheme();

      // Initialize history
      loadImageHistory();

      // Set up clear history button
      document.getElementById("clearHistoryBtn").addEventListener('click', () => {
        localStorage.removeItem('falGeneratedImages');
        document.getElementById('historyRow').innerHTML =
          '<div class="text-center text-gray-300 dark:text-gray-500 text-sm italic w-full py-6">æš‚æ— å†å²å›¾ç‰‡</div>';

        // Destroy viewer instance if it exists
        if (historyViewer) {
          historyViewer.destroy();
          historyViewer = null;
        }
      });

      // Initialize the main application logic
      initializeFalApp();

      setupViewerKeybindings(); // è®¾ç½® Viewer.js çš„ WSAD å¿«æ·é”®ç›‘å¬å™¨

      const historyRow = document.getElementById('historyRow');
      if(historyRow) {
        let targetScrollLeft = historyRow.scrollLeft; // ç›®æ ‡æ»šåŠ¨ä½ç½®
        let animationFrameId = null; // å­˜å‚¨ requestAnimationFrame ID
        const easingFactor = 0.15; // ç¼“åŠ¨å› å­
        let isWheeling = false; // æ ‡è®°æ˜¯å¦ç”± wheel äº‹ä»¶è§¦å‘æ»šåŠ¨
        let isManualScrolling = false; // æ ‡è®°æ˜¯å¦æ˜¯ç”¨æˆ·æ‰‹åŠ¨æ‹–åŠ¨æ»šåŠ¨æ¡

        const smoothScroll = () => {
          // å¦‚æœæ˜¯ç”¨æˆ·æ‰‹åŠ¨æ‹–åŠ¨æ»šåŠ¨æ¡ï¼Œåˆ™åœæ­¢åŠ¨ç”»
          if (isManualScrolling) {
              cancelAnimationFrame(animationFrameId);
              animationFrameId = null;
              isWheeling = false; // ç¡®ä¿ wheel çŠ¶æ€ä¹Ÿé‡ç½®
              return;
          }

          const currentScroll = historyRow.scrollLeft;
          const diff = targetScrollLeft - currentScroll;

          // å¦‚æœå·®å¼‚å¾ˆå°ï¼Œåœæ­¢åŠ¨ç”»å¹¶ç²¾ç¡®è®¾ç½®æœ€ç»ˆä½ç½®
          if (Math.abs(diff) < 1) {
            historyRow.scrollLeft = targetScrollLeft;
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            isWheeling = false; // åŠ¨ç”»ç»“æŸï¼Œé‡ç½® wheel çŠ¶æ€
            return;
          }

          // è®¡ç®—ä¸‹ä¸€æ­¥çš„æ»šåŠ¨ä½ç½®
          const step = currentScroll + diff * easingFactor;
          historyRow.scrollLeft = step;

          // ç»§ç»­ä¸‹ä¸€å¸§åŠ¨ç”»
          animationFrameId = requestAnimationFrame(smoothScroll);
        };

        // ç›‘å¬ wheel äº‹ä»¶ä»¥å®ç°å¹³æ»‘æ»šåŠ¨
        historyRow.addEventListener('wheel', (e) => {
          // é˜»æ­¢é¡µé¢é»˜è®¤çš„å‚ç›´æ»šåŠ¨è¡Œä¸º
          e.preventDefault();
          isWheeling = true; // æ ‡è®°æ»šåŠ¨æ˜¯ç”± wheel è§¦å‘
          isManualScrolling = false; // wheel äº‹ä»¶å‘ç”Ÿï¼Œä¸æ˜¯æ‰‹åŠ¨æ‹–åŠ¨

          // å¦‚æœåŠ¨ç”»æ­£åœ¨è¿è¡Œï¼ŒåŸºäºå½“å‰å®é™…ä½ç½®æ›´æ–°ç›®æ ‡ä½ç½®
          // å¦åˆ™ï¼Œä»å½“å‰ä½ç½®å¼€å§‹è®¡ç®—
          targetScrollLeft = historyRow.scrollLeft + e.deltaY;

          // é™åˆ¶ç›®æ ‡ä½ç½®åœ¨æœ‰æ•ˆèŒƒå›´å†…
          const maxScrollLeft = historyRow.scrollWidth - historyRow.clientWidth;
          targetScrollLeft = Math.max(0, Math.min(targetScrollLeft, maxScrollLeft));

          // å¦‚æœåŠ¨ç”»æ²¡æœ‰åœ¨è¿è¡Œï¼Œå¯åŠ¨å®ƒ
          if (!animationFrameId) {
            animationFrameId = requestAnimationFrame(smoothScroll);
          }
        }, { passive: false }); // éœ€è¦ passive: false æ¥è°ƒç”¨ preventDefault

        // ç›‘å¬ scroll äº‹ä»¶ä»¥æ£€æµ‹æ‰‹åŠ¨æ‹–åŠ¨
        historyRow.addEventListener('scroll', () => {
          // å¦‚æœæ»šåŠ¨äº‹ä»¶å‘ç”Ÿï¼Œä½†ä¸æ˜¯ç”± wheel äº‹ä»¶åŠ¨ç”»è§¦å‘çš„ï¼Œ
          // åˆ™è®¤ä¸ºæ˜¯ç”¨æˆ·æ‰‹åŠ¨æ‹–åŠ¨æ»šåŠ¨æ¡
          if (!isWheeling) {
            isManualScrolling = true; // æ ‡è®°ä¸ºæ‰‹åŠ¨æ»šåŠ¨
            // å¦‚æœæ­¤æ—¶æœ‰ wheel åŠ¨ç”»åœ¨è¿è¡Œï¼Œå–æ¶ˆå®ƒ
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            // æ›´æ–° targetScrollLeft ä¸ºå½“å‰æ‰‹åŠ¨æ»šåŠ¨åˆ°çš„ä½ç½®ï¼Œé˜²æ­¢ wheel äº‹ä»¶å†æ¬¡è§¦å‘æ—¶è·³è·ƒ
            targetScrollLeft = historyRow.scrollLeft;
          }
          // å¦‚æœæ»šåŠ¨æ˜¯ç”± wheel åŠ¨ç”»å¼•èµ·çš„ï¼Œåˆ™åœ¨ smoothScroll å‡½æ•°ç»“æŸæ—¶ isWheeling ä¼šè¢«è®¾ä¸º false
        });

        // ç›‘å¬é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶ï¼Œæ›´æ—©åœ°åˆ¤æ–­æ‰‹åŠ¨æ‹–åŠ¨å¼€å§‹
        historyRow.addEventListener('mousedown', (e) => {
            // åˆ¤æ–­ç‚¹å‡»äº‹ä»¶æ˜¯å¦å‘ç”Ÿåœ¨æ»šåŠ¨æ¡ä¸Š (è¿‘ä¼¼åˆ¤æ–­)
            // offsetX/Y ç›¸å¯¹äºå…ƒç´ è¾¹ç•Œï¼ŒclientHeight/Width æ˜¯å…ƒç´ å¯è§†åŒºåŸŸå¤§å°
            const scrollbarHeight = historyRow.offsetHeight - historyRow.clientHeight; // ä¼°ç®—æ¨ªå‘æ»šåŠ¨æ¡é«˜åº¦
            const scrollbarWidth = historyRow.offsetWidth - historyRow.clientWidth; // ä¼°ç®—çºµå‘æ»šåŠ¨æ¡å®½åº¦ (è™½ç„¶è¿™é‡Œä¸»è¦æ˜¯æ¨ªå‘)

            // å¦‚æœç‚¹å‡»ä½ç½®åœ¨ä¼°ç®—çš„æ»šåŠ¨æ¡åŒºåŸŸå†…
            if (e.offsetY >= historyRow.clientHeight && scrollbarHeight > 0 ||
                e.offsetX >= historyRow.clientWidth && scrollbarWidth > 0)
            {
                isManualScrolling = true;
                isWheeling = false; // ç¡®ä¿ wheel çŠ¶æ€å…³é—­
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            }
        });

        // ç›‘å¬é¼ æ ‡æ¾å¼€äº‹ä»¶ï¼Œé‡ç½®æ‰‹åŠ¨æ»šåŠ¨æ ‡è®°
        // ä½¿ç”¨ window ç›‘å¬ mouseupï¼Œä»¥é˜²é¼ æ ‡åœ¨å…ƒç´ å¤–æ¾å¼€
        window.addEventListener('mouseup', () => {
            if (isManualScrolling) {
                isManualScrolling = false;
                // æ›´æ–° targetScrollLeftï¼Œä»¥ä¾¿ä¸‹æ¬¡ wheel äº‹ä»¶ä»æ­£ç¡®ä½ç½®å¼€å§‹
                targetScrollLeft = historyRow.scrollLeft;
            }
        });

        // å½“é¼ æ ‡ç¦»å¼€ historyRow æ—¶ï¼Œä¹Ÿå¯èƒ½æ„å‘³ç€æ‹–åŠ¨ç»“æŸ
        historyRow.addEventListener('mouseleave', () => {
             if (isManualScrolling) {
                // ä¸ç«‹å³é‡ç½® isManualScrollingï¼Œå› ä¸ºå¯èƒ½è¿˜åœ¨æ‹–åŠ¨ä¸­é¼ æ ‡ç§»å‡ºå»äº†
                // mouseup äº‹ä»¶ä¼šæœ€ç»ˆå¤„ç†
             }
        });
      }

      // Initialize image viewers after a short delay
      setTimeout(() => {
        initializeViewers();
      }, 1000);

      // Initialize sliders to update their display values
      document.getElementById('numInferenceSteps').addEventListener('input', (e) => {
        document.getElementById('numInferenceStepsValue').textContent = e.target.value;
      });

      document.getElementById('guidanceScale').addEventListener('input', (e) => {
        document.getElementById('guidanceScaleValue').textContent = e.target.value;
      });

      // Custom image size setup
      const imageSizeSelect = document.getElementById('imageSize');
      imageSizeSelect.addEventListener('change', (e) => {
        const customSizeContainer = document.getElementById('customSizeContainer');
        if (e.target.value === 'custom') {
          customSizeContainer.classList.remove('hidden');
          // Add fade-in animation
          customSizeContainer.classList.add('fade-in');
        } else {
          // Hide (no fade-out needed as it's simple hide)
          customSizeContainer.classList.add('hidden');
        }
      });

      // Advanced options toggle animation
      document.getElementById('toggleAdvanced').addEventListener('click', (e) => {
        const advancedOptions = document.getElementById('advancedOptions');
        const isHidden = advancedOptions.classList.contains('hidden');

        if (isHidden) {
          advancedOptions.classList.remove('hidden');
          // Add fade-in animation
          advancedOptions.classList.add('fade-in');
          e.target.textContent = 'éšè—';
        } else {
          // Use setTimeout for fade-out effect before hiding
          advancedOptions.style.opacity = '0';
          advancedOptions.style.transition = 'opacity 0.3s';

          setTimeout(() => {
            advancedOptions.classList.add('hidden');
            advancedOptions.style.opacity = ''; // Reset opacity
            advancedOptions.style.transition = ''; // Reset transition
          }, 300);

          e.target.textContent = 'æ˜¾ç¤º';
        }
      });

      // --- Added: Custom model input logic ---
      const modelSelect = document.getElementById('model');
      const customModelInput = document.getElementById('customModelInput');

      modelSelect.addEventListener('change', (e) => {
        if (e.target.value === 'custom') {
          customModelInput.classList.add('visible'); // Use 'visible' class to trigger transition
        } else {
          customModelInput.classList.remove('visible');
        }
      });
      // --- End: Custom model input logic ---

      loadUserSettings(); // åŠ è½½ç”¨æˆ·è®¾ç½®
      setupSettingsListeners(); // è®¾ç½®ç›‘å¬å™¨
    });

    // Initialize theme based on localStorage or preference
    function initTheme() {
      const themeToggle = document.getElementById('themeToggle');

      // Check theme preference in localStorage
      const darkMode = localStorage.getItem('darkMode') === 'true';

      // Set initial state
      if (darkMode) {
        document.body.classList.remove('light');
        document.body.classList.add('dark');
        themeToggle.checked = true;
      } else {
        document.body.classList.add('light');
        document.body.classList.remove('dark');
        themeToggle.checked = false;
      }

      // Add toggle event listener
      themeToggle.addEventListener('change', function() {
        // Add page transition animation
        document.body.style.opacity = '0.8';
        document.body.style.transition = 'opacity 0.3s ease';

        setTimeout(() => {
          if (this.checked) {
            document.body.classList.remove('light');
            document.body.classList.add('dark');
            localStorage.setItem('darkMode', 'true');
          } else {
            document.body.classList.add('light');
            document.body.classList.remove('dark');
            localStorage.setItem('darkMode', 'false');
          }

          // Restore visibility after transition
          setTimeout(() => {
            document.body.style.opacity = '1';
          }, 50);
        }, 300);
      });
    }

    // Initialize all image viewers (Viewer.js)
    function initializeViewers() {
      console.log("Initializing image viewers...");

      // Check if Viewer.js is loaded
      if (!isViewerLoaded()) {
        console.error("Viewer.js not loaded, image viewing functionality will be unavailable.");
        return;
      }

      try {
        // Initialize history image viewer
        const historyElement = document.getElementById('historyRow');
        if (historyElement && historyElement.querySelector('img')) {
          console.log("Initializing history image viewer");

          // Destroy existing viewer if present
          if (historyViewer) {
            historyViewer.destroy();
          }

          // Create new viewer
          historyViewer = new Viewer(historyElement, {
            inline: false, // Show viewer on click, not inline
            button: true, // Show fullscreen button
            navbar: false, // Hide thumbnail navigation
            title: false, // Hide title
            toolbar: { // Customize toolbar buttons
              zoomIn: 1,
              zoomOut: 1,
              oneToOne: 1,
              reset: 1,
              prev: 1,
              next: 1,
              rotateLeft: 1,
              rotateRight: 1,
              flipHorizontal: 1,
              flipVertical: 1,
            },
            keyboard: true,
            viewed() {
              console.log('History image viewer initialized');
            }
          });
        }

        // Initialize results image viewer
        const resultsElement = document.getElementById('results');
        if (resultsElement && resultsElement.querySelector('img')) {
          console.log("Initializing results image viewer");

          // Destroy existing viewer if present
          if (resultsViewer) {
            resultsViewer.destroy();
          }

          // Create new viewer
          resultsViewer = new Viewer(resultsElement, {
            inline: false,
            button: true,
            navbar: false,
            title: false,
            toolbar: {
              zoomIn: 1,
              zoomOut: 1,
              oneToOne: 1,
              reset: 1,
              prev: 1,
              next: 1,
              rotateLeft: 1,
              rotateRight: 1,
              flipHorizontal: 1,
              flipVertical: 1,
            },
            keyboard: true,
            viewed() {
              console.log('Results image viewer initialized');
            }
          });
        }
      } catch (error) {
        console.error("Error initializing viewers:", error);
      }
    }

     // --- æ–°å¢ï¼šä¸º Viewer.js æ·»åŠ  WSAD å¿«æ·é”® ---
    function setupViewerKeybindings() {
      document.addEventListener('keydown', (event) => {
        // æ£€æŸ¥æ˜¯å¦æœ‰ Viewer å®ä¾‹å¤„äºæ´»åŠ¨çŠ¶æ€
        const activeViewer = (historyViewer && historyViewer.isShown) ? historyViewer :
                             (resultsViewer && resultsViewer.isShown) ? resultsViewer : null;

        if (!activeViewer) {
          return; // å¦‚æœæ²¡æœ‰æ´»åŠ¨çš„ Viewerï¼Œåˆ™ä¸æ‰§è¡Œä»»ä½•æ“ä½œ
        }

        let handled = false;
        switch (event.key.toLowerCase()) {
          case 'w': // æ¨¡æ‹Ÿå‘ä¸Šç®­å¤´ (æ”¾å¤§)
            activeViewer.zoom(0.1);
            handled = true;
            break;
          case 's': // æ¨¡æ‹Ÿå‘ä¸‹ç®­å¤´ (ç¼©å°)
            activeViewer.zoom(-0.1);
            handled = true;
            break;
          case 'a': // æ¨¡æ‹Ÿå‘å·¦ç®­å¤´ (ä¸Šä¸€å¼ )
            activeViewer.prev();
            handled = true;
            break;
          case 'd': // æ¨¡æ‹Ÿå‘å³ç®­å¤´ (ä¸‹ä¸€å¼ )
            activeViewer.next();
            handled = true;
            break;
        }

        if (handled) {
          event.preventDefault(); // é˜»æ­¢é»˜è®¤è¡Œä¸º (ä¾‹å¦‚é¡µé¢æ»šåŠ¨)
        }
      });
      console.log("WSAD viewer keybindings setup.");
    }

    // --- Modified: Save image to history, including model info ---
    /**
     * Saves generated images to localStorage history.
     * @param {Array<object>} images - Array of image objects from API response.
     * @param {string} prompt - The prompt used for generation.
     * @param {string} modelId - The model ID used for generation.
     */
    function saveToHistory(images, prompt, modelId) {
      // Get existing history or initialize an empty array
      let history = JSON.parse(localStorage.getItem('falGeneratedImages') || '[]');

      // Add new images
      const timestamp = new Date().toISOString();
      const newImages = images.map(img => ({
        url: img.url,
        prompt,
        timestamp,
        model: modelId // Save the currently used model ID
      }));

      // Add to the beginning of the array
      history = [...newImages, ...history];

      // Limit history to a maximum of 50 images
      // if (history.length > 50) {
      //   history = history.slice(0, 50);
      // }

      // Save back to localStorage
      localStorage.setItem('falGeneratedImages', JSON.stringify(history));

      // Update history display
      loadImageHistory();

      // Re-initialize viewers after a short delay to allow DOM update
      setTimeout(() => {
        initializeViewers();
      }, 500);
    }
    // --- End modification ---
    let currentTooltip = null;
    let hideTooltipTimer = null;

    function deleteHistoryImage(index) {
      // 1. æ›´æ–° localStorage
      const history = JSON.parse(localStorage.getItem('falGeneratedImages') || '[]');
      history.splice(index, 1);
      localStorage.setItem('falGeneratedImages', JSON.stringify(history));

      // 2. åªç§»é™¤å¯¹åº”çš„ DOM èŠ‚ç‚¹
      const historyRow = document.getElementById('historyRow');
      const items = historyRow.querySelectorAll('.history-item');
      const target = items[index];
      if (target) {
        // å¦‚æœæœ‰ tooltip èŠ‚ç‚¹ï¼Œä¹Ÿä¸€å¹¶æ¸…ç†
        const tooltip = document.querySelector('body > .fixed.z-50');
        tooltip && tooltip.remove();
        target.remove();
      }

      // 3. ï¼ˆå¯é€‰ï¼‰é‡æ–°è°ƒæ•´ Viewer.js
      if (historyViewer) {
        historyViewer.update(); // æˆ–è€… destroy/reinit
      }
    }

    // Load and display image history from localStorage
    function loadImageHistory() {
      const historyRow = document.getElementById('historyRow');
      const history = JSON.parse(localStorage.getItem('falGeneratedImages') || '[]');

      if (history.length === 0) {
        historyRow.innerHTML = '<div class="text-center text-gray-300 dark:text-gray-500 text-sm italic w-full py-6">æš‚æ— å†å²å›¾ç‰‡</div>';
        return;
      }

      // Clear and populate the history row
      historyRow.innerHTML = '';

      history.forEach((item, index) => {
        const imageContainer = document.createElement('div');
        imageContainer.className = 'flex-shrink-0 relative fade-in history-item';
        // Add staggered animation delay
        imageContainer.style.animationDelay = `${index * 0.05}s`;

        const image = document.createElement('img');
        image.src = item.url;
        // Display model and prompt in alt text and tooltip
        image.alt = `æ¨¡å‹: ${item.model || 'æœªçŸ¥'} | æç¤º: ${item.prompt.substring(0, 20)}...`;
        image.className = 'history-image';
        image.loading = 'lazy'; // Lazy load images
        image.setAttribute('data-original', item.url); // For Viewer.js

        // Add hover tooltip
        const tooltip = document.createElement('div');
        // å°†tooltipå®šä½åœ¨å›¾ç‰‡ä¸‹æ–¹è€Œä¸æ˜¯ä¸Šæ–¹ï¼Œå¢åŠ z-indexç¡®ä¿æ˜¾ç¤ºåœ¨æœ€ä¸Šå±‚
        tooltip.className = 'fixed z-50 p-2 bg-black/90 text-white text-xs rounded shadow-lg border border-white/20 pointer-events-none opacity-0 transition-opacity duration-200';
        tooltip.style.maxWidth = '250px';
        tooltip.style.wordBreak = 'break-word';
        tooltip.innerHTML = `
          <p class="mb-1"><strong>æ¨¡å‹:</strong> ${item.model || 'æœªçŸ¥'}</p>
          <p class="mb-1"><strong>æç¤º:</strong> ${item.prompt}</p>
          <p><strong>æ—¶é—´:</strong> ${new Date(item.timestamp).toLocaleString()}</p>
        `;
        document.body.appendChild(tooltip);

        // --- Tooltip Logic Start ---
        const showDelay = 150; // Optional: Delay before showing tooltip
        const hideDelay = 300; // Delay before hiding tooltip

        let showTooltipTimer = null;

        imageContainer.addEventListener('mouseenter', (e) => {
          // Clear any pending hide operations for other tooltips
          clearTimeout(hideTooltipTimer);
          // Immediately hide any other currently visible tooltip
          if (currentTooltip && currentTooltip !== tooltip) {
            currentTooltip.classList.remove('opacity-100');
            currentTooltip.classList.add('opacity-0');
            // Allow interaction with the tooltip content
            currentTooltip.style.pointerEvents = 'none';
            currentTooltip = null;
          }

          // Clear any pending show for this tooltip (if mouse quickly enters/leaves/re-enters)
          clearTimeout(showTooltipTimer);

          // Optional: Add a small delay before showing
          showTooltipTimer = setTimeout(() => {
            const rect = imageContainer.getBoundingClientRect(); // Use imageContainer for positioning
            tooltip.style.left = `${rect.left + rect.width / 2 - tooltip.offsetWidth / 2}px`;
            tooltip.style.top = `${rect.bottom + 8}px`; // Increased gap slightly

            // Ensure tooltip doesn't go off-screen horizontally
            const tooltipRect = tooltip.getBoundingClientRect(); // Get rect *after* setting position
            const viewportWidth = window.innerWidth;
            if (tooltipRect.right > viewportWidth - 10) { // Add small margin
              tooltip.style.left = `${viewportWidth - tooltip.offsetWidth - 10}px`;
            }
            if (tooltipRect.left < 10) { // Add small margin
              tooltip.style.left = '10px';
            }
            // Ensure tooltip doesn't go off-screen vertically (bottom) - less common but possible
            const viewportHeight = window.innerHeight;
            if (tooltipRect.bottom > viewportHeight - 10) {
              tooltip.style.top = `${rect.top - tooltip.offsetHeight - 8}px`; // Move above image if no space below
            }


            tooltip.classList.remove('opacity-0');
            tooltip.classList.add('opacity-100');
            // Allow interaction ONLY when visible
            tooltip.style.pointerEvents = 'auto';
            currentTooltip = tooltip; // Set this as the current tooltip
          }, showDelay);
        });

        imageContainer.addEventListener('mouseleave', () => {
          // Clear pending show timer if mouse leaves before it triggers
          clearTimeout(showTooltipTimer);
          // Start timer to hide this tooltip
          clearTimeout(hideTooltipTimer); // Clear previous hide timer if any
          hideTooltipTimer = setTimeout(() => {
            if (tooltip) { // Check if tooltip still exists
              tooltip.classList.remove('opacity-100');
              tooltip.classList.add('opacity-0');
              tooltip.style.pointerEvents = 'none'; // Disable interaction when hidden
              if (currentTooltip === tooltip) {
                currentTooltip = null; // Clear global reference if it's this one hiding
              }
            }
          }, hideDelay);
        });

        // Keep tooltip visible if mouse enters the tooltip itself
        tooltip.addEventListener('mouseenter', () => {
          clearTimeout(hideTooltipTimer); // Cancel the hide timer
        });

        // Hide tooltip if mouse leaves the tooltip area
        tooltip.addEventListener('mouseleave', () => {
          clearTimeout(hideTooltipTimer); // Clear previous hide timer
          hideTooltipTimer = setTimeout(() => {
            if (tooltip) { // Check if tooltip still exists
                tooltip.classList.remove('opacity-100');
                tooltip.classList.add('opacity-0');
                tooltip.style.pointerEvents = 'none';
                if (currentTooltip === tooltip) {
                    currentTooltip = null;
                }
            }
          }, hideDelay);
        });
        // --- Tooltip Logic End ---

        // Add delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.innerHTML = 'Ã—';
        deleteBtn.className = 'delete-btn';
        deleteBtn.title = 'åˆ é™¤å›¾ç‰‡';
        deleteBtn.addEventListener('click', () => {
          const historyRow = document.getElementById('historyRow');
          const items = Array.from(historyRow.querySelectorAll('.history-item'));
          const currentIndex = items.indexOf(imageContainer);
          if (currentIndex !== -1) {
            deleteHistoryImage(currentIndex);
          }
        });
        imageContainer.appendChild(deleteBtn);

        imageContainer.appendChild(image);
        historyRow.appendChild(imageContainer);
      });
    }

    // Create a direct API implementation (no external library)
    function createDirectApiImplementation() {
      console.log("Creating API implementation");

      return {
        _key: null, // Stores the API key
        /**
         * Configures the API key.
         * @param {object} options - Configuration options.
         * @param {string} options.credentials - The API key.
         * @returns {boolean} True if configuration was successful.
         */
        config(options) {
          if (options && options.credentials) {
            this._key = options.credentials;
            return true;
          }
          return false;
        },
        /**
         * Runs a synchronous request to the Fal API.
         * @param {string} modelId - The ID of the model to run.
         * @param {object} options - Request options.
         * @param {object} options.input - The input data for the model.
         * @returns {Promise<object>} The API response.
         */
        async run(modelId, options) {
            if (!this._key) {
                throw new Error("APIå¯†é’¥æœªé…ç½®");
            }

            const apiUrl = `https://fal.run/${modelId}`;
            console.log("Running synchronous request to:", apiUrl);
            addLog(`INFO: Starting synchronous request to ${modelId}...`, 'info');

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Authorization': `Key ${this._key}`,
                    'Content-Type': 'application/json',
                    // 'mode': 'cors' // 'mode' is not a standard header, removed
                },
                body: JSON.stringify(options.input || {})
            }).catch(error => {
                // Handle potential CORS or network errors
                if (error.message.includes('CORS') || error.message.includes('Failed to fetch')) {
                    throw new Error('CORSé”™è¯¯: æµè§ˆå™¨é˜»æ­¢äº†è¯·æ±‚ã€‚è¯·æ£€æŸ¥æµè§ˆå™¨æ§åˆ¶å°è·å–è¯¦ç»†ä¿¡æ¯ã€‚');
                }
                throw error; // Re-throw other errors
            });

            if (!response.ok) {
                const errorText = await response.text();
                addLog(`ERROR: API request failed: ${response.status} ${errorText}`, 'error');
                throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} ${errorText}`);
            }

            const result = await response.json();
            addLog(`INFO: Synchronous request successful, received result.`, 'info');
            console.log("Synchronous result:", result);
            return result;
        },
        /**
         * Subscribes to an asynchronous request using the Fal queue API.
         * @param {string} modelId - The ID of the model to run.
         * @param {object} options - Request options.
         * @param {object} options.input - The input data for the model.
         * @returns {Promise<object>} The final API response after polling.
         */
        async subscribe(modelId, options) {
          if (!this._key) {
            throw new Error("APIå¯†é’¥æœªé…ç½®");
          }

          try {
            // Submit the request to the queue first
            console.log("Submitting request to queue...");
            addLog(`INFO: Starting asynchronous request to ${modelId}...`, 'info');
            const queueUrl = `https://queue.fal.run/${modelId}`;
            console.log("Queue URL:", queueUrl);

            const submitResponse = await fetch(queueUrl, {
              method: 'POST',
              headers: {
                'Authorization': `Key ${this._key}`,
                'Content-Type': 'application/json',
                // 'mode': 'cors' // 'mode' is not a standard header, removed
              },
              body: JSON.stringify(options.input || {})
            }).catch(error => {
              if (error.message.includes('CORS') || error.message.includes('Failed to fetch')) {
                throw new Error('CORSé”™è¯¯: æµè§ˆå™¨é˜»æ­¢äº†è¯·æ±‚ã€‚è¯·æ£€æŸ¥æµè§ˆå™¨æ§åˆ¶å°è·å–è¯¦ç»†ä¿¡æ¯ã€‚');
              }
              throw error;
            });

            if (!submitResponse.ok) {
              const errorText = await submitResponse.text();
              addLog(`ERROR: Queue submission failed: ${submitResponse.status} ${errorText}`, 'error');
              throw new Error(`APIè¯·æ±‚å¤±è´¥: ${submitResponse.status} ${errorText}`);
            }

            const queueData = await submitResponse.json();
            addLog(`INFO: Request submitted to queue, Request ID: ${queueData.request_id}`, 'info');
            console.log("Queue response:", queueData);

            // Use the URLs returned in the response
            const { request_id, status_url, response_url } = queueData;

            // Poll until completion
            const self = this; // Reference 'this' for use inside poll function
            let statusData;
            let attempts = 0;
            const maxAttempts = 60; // Poll max 60 times (approx 5 minutes)
            const pollInterval = 5000; // Poll every 5 seconds

            return new Promise((resolve, reject) => {
              const poll = async () => {
                attempts++;
                if (attempts > maxAttempts) {
                  addLog(`ERROR: Request timed out (exceeded ${maxAttempts * pollInterval / 1000} seconds)`, 'error');
                  reject(new Error("è¯·æ±‚è¶…æ—¶"));
                  return;
                }

                try {
                  console.log(`Polling status (${attempts}/${maxAttempts}):`, status_url);
                  addLog(`INFO: Polling status (${attempts}/${maxAttempts})...`, 'info');
                  const statusResponse = await fetch(status_url, {
                    headers: {
                      'Authorization': `Key ${self._key}`,
                      // 'mode': 'cors' // 'mode' is not a standard header, removed
                    }
                  });

                  if (!statusResponse.ok) {
                    const errorText = await statusResponse.text();
                    addLog(`ERROR: Failed to get status: ${statusResponse.status} ${errorText}`, 'error');
                    // Continue polling, might be a temporary issue
                    setTimeout(poll, pollInterval);
                    return;
                  }

                  statusData = await statusResponse.json();
                  console.log("Status data:", statusData);

                  // Update loading status text
                  const loadingStatus = document.getElementById('loadingStatus');
                  if (loadingStatus) {
                    loadingStatus.textContent = `å¤„ç†ä¸­... ${statusData.progress ? statusData.progress.current + '/' + statusData.progress.total : ''}`;
                  }

                  // Log detailed logs if available
                  if (statusData.logs && statusData.logs.length > 0) {
                      // Only log new messages to avoid repetition
                      const lastLoggedIndex = parseInt(loadingStatus.dataset.lastLogIndex || '-1');
                      statusData.logs.slice(lastLoggedIndex + 1).forEach((log, index) => {
                          addLog(`LOG: ${log.message}`, 'info');
                          loadingStatus.dataset.lastLogIndex = (lastLoggedIndex + 1 + index).toString();
                      });
                  }


                  if (statusData.status === 'COMPLETED') {
                    addLog(`INFO: Request completed! Fetching results...`, 'info');
                    // Get the final result
                    const resultResponse = await fetch(response_url, {
                      headers: {
                        'Authorization': `Key ${self._key}`,
                        // 'mode': 'cors' // 'mode' is not a standard header, removed
                      }
                    });

                    if (!resultResponse.ok) {
                      const errorText = await resultResponse.text();
                       addLog(`ERROR: Failed to get result: ${resultResponse.status} ${errorText}`, 'error');
                      reject(new Error(`è·å–ç»“æœå¤±è´¥: ${resultResponse.status} ${errorText}`));
                      return;
                    }

                    const result = await resultResponse.json();
                    addLog(`INFO: Successfully fetched result.`, 'info');
                    console.log("Final result:", result);
                    resolve(result); // Return the result

                  } else if (statusData.status === 'FAILED' || statusData.status === 'ERROR') {
                    addLog(`ERROR: Request failed: ${statusData.error ? statusData.error.message : 'æœªçŸ¥é”™è¯¯'}`, 'error');
                    reject(new Error(`è¯·æ±‚å¤±è´¥: ${statusData.error ? statusData.error.message : 'æœªçŸ¥é”™è¯¯'}`));
                  } else {
                    // Continue polling
                    setTimeout(poll, pollInterval);
                  }
                } catch (error) {
                  console.error("Polling error:", error);
                  addLog(`ERROR: Error during polling: ${error.message}`, 'error');
                  // If it's a CORS error, reject immediately
                  if (error.message.includes('CORS')) {
                      reject(new Error('CORSé”™è¯¯: æµè§ˆå™¨é˜»æ­¢äº†è½®è¯¢è¯·æ±‚ã€‚'));
                  } else {
                      // For other errors, retry a few times
                      if (attempts <= 3) { // Allow retries for network errors
                          setTimeout(poll, pollInterval * 2); // Increase wait time
                      } else {
                          reject(error); // Reject after multiple failed attempts
                      }
                  }
                }
              };

              // Initial poll
              // Reset last log index before starting polling
              const loadingStatus = document.getElementById('loadingStatus');
              if(loadingStatus) loadingStatus.dataset.lastLogIndex = '-1';
              setTimeout(poll, pollInterval);
            });

          } catch (error) {
            console.error("API call failed:", error);
            addLog(`ERROR: API call failed: ${error.message}`, 'error');
            throw error; // Re-throw the error
          }
        }
      };
    }

    // Initialize the main Fal application logic
    function initializeFalApp() {
      // Get references to DOM elements
      const apiKeyInput = document.getElementById('apiKeyInput');
      const saveApiKey = document.getElementById('saveApiKey');
      const keyStatus = document.getElementById('keyStatus');
      const generationForm = document.getElementById('generationForm');
      const promptInput = document.getElementById('prompt');
      const modelSelect = document.getElementById('model');
      const customModelInput = document.getElementById('customModelInput'); // Get custom model input
      const seedInput = document.getElementById('seed');
      const imageSizeSelect = document.getElementById('imageSize');
      const customWidthInput = document.getElementById('customWidth');
      const customHeightInput = document.getElementById('customHeight');
      const numImagesInput = document.getElementById('numImages');
      const numInferenceStepsInput = document.getElementById('numInferenceSteps');
      const guidanceScaleInput = document.getElementById('guidanceScale');
      const rawModeInput = document.getElementById('rawMode'); // è·å–è‡ªç„¶æ¨¡å¼å¼€å…³å¼•ç”¨
      const syncModeInput = document.getElementById('syncMode');
      const enableSafetyCheckerInput = document.getElementById('enableSafetyChecker');
      const generateBtn = document.getElementById('generateBtn');
      const loadingDiv = document.getElementById('loading');
      const loadingStatus = document.getElementById('loadingStatus');
      const resultsDiv = document.getElementById('results');
      const errorMessageDiv = document.getElementById('errorMessage');

      // Create API instance
      const fal = createDirectApiImplementation();

      // Load saved API Key from sessionStorage
      const savedKey = sessionStorage.getItem('falApiKey');
      if (savedKey) {
        apiKeyInput.value = savedKey;
        const configured = fal.config({ credentials: savedKey });
        keyStatus.textContent = configured ? 'âœ… å¯†é’¥å·²åŠ è½½' : 'âŒ å¯†é’¥é…ç½®å¤±è´¥';
        keyStatus.className = configured ? 'mt-2 text-sm text-green-300' : 'mt-2 text-sm text-red-300';
      } else {
        keyStatus.textContent = 'ğŸ”‘ è¯·è¾“å…¥å¹¶ä¿å­˜æ‚¨çš„APIå¯†é’¥';
        keyStatus.className = 'mt-2 text-sm text-yellow-300';
      }

      // Save API Key to sessionStorage
      saveApiKey.addEventListener('click', () => {
        const apiKey = apiKeyInput.value.trim();
        if (apiKey) {
          sessionStorage.setItem('falApiKey', apiKey);
          const configured = fal.config({ credentials: apiKey });
          keyStatus.textContent = configured ? 'âœ… å¯†é’¥å·²ä¿å­˜' : 'âŒ å¯†é’¥é…ç½®å¤±è´¥';
          keyStatus.className = configured ? 'mt-2 text-sm text-green-300' : 'mt-2 text-sm text-red-300';
          addLog('INFO: API key saved to session storage.', 'info');
        } else {
          sessionStorage.removeItem('falApiKey');
          fal.config({ credentials: null }); // Clear configuration
          keyStatus.textContent = 'ğŸ”‘ è¯·è¾“å…¥å¹¶ä¿å­˜æ‚¨çš„APIå¯†é’¥';
          keyStatus.className = 'mt-2 text-sm text-yellow-300';
          addLog('WARN: API key cleared.', 'warn');
        }
      });

      // Handle form submission
      generationForm.addEventListener('submit', async (e) => {
        e.preventDefault(); // Prevent default form submission

        // Check if API Key is configured
        if (!fal._key) {
          showError("è¯·å…ˆè¾“å…¥å¹¶ä¿å­˜æ‚¨çš„APIå¯†é’¥ã€‚");
          addLog('ERROR: API key not configured, cannot generate image.', 'error');
          return;
        }

        // Get form data
        const prompt = promptInput.value.trim();
        if (!prompt) {
          showError("è¯·è¾“å…¥æç¤ºè¯ã€‚");
          addLog('WARN: Prompt is empty.', 'warn');
          return;
        }

        // --- Modified: Get model ID ---
        let modelId = modelSelect.value;
        if (modelId === 'custom') {
          modelId = customModelInput.value.trim();
          if (!modelId) {
            showError("è¯·è¾“å…¥è‡ªå®šä¹‰æ¨¡å‹çš„å€¼ã€‚");
            addLog('WARN: Custom model selected but no value entered.', 'warn');
            return;
          }
           // Simple validation for format (optional)
          if (!modelId.includes('/')) {
              showError("è‡ªå®šä¹‰æ¨¡å‹å€¼æ ¼å¼é€šå¸¸ä¸º 'username/model-name'ã€‚");
              addLog('WARN: Custom model value format might be incorrect.', 'warn');
              return;
          }
        }
        // --- End modification ---

        const seed = seedInput.value ? parseInt(seedInput.value) : null;
        const imageSize = imageSizeSelect.value;
        // é™åˆ¶å›¾åƒæ•°é‡æœ€å¤§ä¸º4
        let numImages = parseInt(numImagesInput.value) || 1;
        if (numImages > 4) {
          numImages = 4;
          numImagesInput.value = "4"; // æ›´æ–°è¾“å…¥æ¡†çš„æ˜¾ç¤ºå€¼
          addLog('WARN: å›¾åƒæ•°é‡å·²è¢«é™åˆ¶ä¸ºæœ€å¤§å€¼4', 'warn');
        }
        const numInferenceSteps = parseInt(numInferenceStepsInput.value) || 28;
        const guidanceScale = parseFloat(guidanceScaleInput.value) || 3.5;
        const rawMode = rawModeInput.checked; // è·å–è‡ªç„¶æ¨¡å¼çŠ¶æ€
        const syncMode = syncModeInput.checked;
        const enableSafetyChecker = enableSafetyCheckerInput.checked;

        // åœ¨å‘é€APIè¯·æ±‚å‰ä¿å­˜å½“å‰é…ç½®
        saveUserSettings();
        // addLog('INFO: å½“å‰é…ç½®å·²ä¿å­˜ï¼Œåˆ·æ–°é¡µé¢åå°†è‡ªåŠ¨è¿˜åŸ', 'info');

        // Build API input parameters
        const input = {
          prompt: prompt,
          num_images: numImages,
          num_inference_steps: numInferenceSteps,
          guidance_scale: guidanceScale,
          enable_safety_checker: enableSafetyChecker,
          raw: rawMode, // æ·»åŠ è‡ªç„¶æ¨¡å¼å‚æ•°
        };

        // Add safety_tolerance when safety checker is disabled
        if (enableSafetyChecker === false) {
          input.safety_tolerance = "6";
        }

        // Add seed if provided and valid
        if (seed !== null && !isNaN(seed)) {
          input.seed = seed;
        }

        // Add image dimensions
        if (imageSize === 'custom') {
            const width = parseInt(customWidthInput.value);
            const height = parseInt(customHeightInput.value);
            if (width && height && width >= 256 && width <= 2048 && height >= 256 && height <= 2048) {
                input.width = width;
                input.height = height;
                
                // è®¡ç®—è‡ªå®šä¹‰å°ºå¯¸çš„å®½é«˜æ¯”
                const gcd = (a, b) => b === 0 ? a : gcd(b, a % b); // è®¡ç®—æœ€å¤§å…¬çº¦æ•°
                const divisor = gcd(width, height);
                const aspectW = width / divisor;
                const aspectH = height / divisor;
                
                // å¦‚æœè®¡ç®—å‡ºçš„æ¯”ä¾‹åœ¨å…è®¸çš„èŒƒå›´å†…ï¼Œåˆ™ä½¿ç”¨å®ƒ
                if (aspectW <= 21 && aspectH <= 21) {
                    input.aspect_ratio = `${aspectW}:${aspectH}`;
                    addLog(`INFO: Using calculated aspect ratio: ${input.aspect_ratio}`, 'info');
                }
            } else {
                showError("è‡ªå®šä¹‰å®½åº¦å’Œé«˜åº¦å¿…é¡»åœ¨ 256 åˆ° 2048 ä¹‹é—´ã€‚");
                addLog('WARN: Invalid custom dimensions.', 'warn');
                return;
            }
        } else {
            // æ ¹æ®é¢„è®¾å°ºå¯¸è®¾ç½® aspect_ratio
            const aspectRatioMap = {
                'square_hd': '1:1',
                'portrait_16_9': '9:16', // ç«–å‘ 16:9 å®é™…ä¸Šæ˜¯ 9:16
                'landscape_16_9': '16:9',
                'landscape_4_3': '4:3'
            };
            
            if (aspectRatioMap[imageSize]) {
                input.aspect_ratio = aspectRatioMap[imageSize];
                addLog(`INFO: Using preset aspect ratio: ${input.aspect_ratio}`, 'info');
            }
            
            if (imageSize !== 'square_hd') { // square_hd is often default, no need to specify
                input.image_size = imageSize;
            }
        }


        // Clear old results and errors, show loading indicator
        resultsDiv.innerHTML = '';
        errorMessageDiv.classList.add('hidden');
        errorMessageDiv.textContent = '';
        loadingDiv.classList.remove('hidden');
        loadingStatus.textContent = 'æ­£åœ¨å¤„ç†è¯·æ±‚...';
        generateBtn.disabled = true;
        generateBtn.textContent = 'ç”Ÿæˆä¸­...';
        // clearLogs(); // Clear previous logs
        document.getElementById('logsContainer').classList.remove('hidden'); // Show log container

        addLog(`INFO: Starting image generation... Model: ${modelId}, Mode: ${syncMode ? 'Sync' : 'Async'}`, 'info');
        addLog(`INFO: Parameters: ${JSON.stringify(input)}`, 'info');


        try {
          let result;
          // Choose API method based on syncMode
          if (syncMode) {
            result = await fal.run(modelId, { input });
          } else {
            result = await fal.subscribe(modelId, { input });
          }


          console.log("API Result:", result);

          // Process the result
          if (result && result.images && result.images.length > 0) {
            displayResults(result.images);
            saveToHistory(result.images, prompt, modelId); // Pass modelId to history
            addLog(`INFO: Successfully generated ${result.images.length} image(s).`, 'info');
          } else {
            // Check for error messages or unsafe content flags
            if (result && result.error) {
                showError(`ç”Ÿæˆå¤±è´¥: ${result.error.message || JSON.stringify(result.error)}`);
                addLog(`ERROR: Generation failed: ${result.error.message || JSON.stringify(result.error)}`, 'error');
            } else if (result && result.has_nsfw_concepts && result.has_nsfw_concepts.some(flag => flag === true)) {
                showError("ç”Ÿæˆçš„å†…å®¹å¯èƒ½åŒ…å«ä¸é€‚å®œä¿¡æ¯ï¼Œå·²è¢«å®‰å…¨æ£€æŸ¥å™¨é˜»æ­¢ã€‚");
                addLog('WARN: Inappropriate content detected, generation blocked.', 'warn');
            } else {
                showError("API è¿”å›äº†ç©ºç»“æœæˆ–æ— æ•ˆå“åº”ã€‚");
                addLog('ERROR: API returned empty or invalid response.', 'error');
                console.error("Invalid API response:", result);
            }
          }
        } catch (error) {
          console.error("Error during generation:", error);
          showError(`å‘ç”Ÿé”™è¯¯: ${error.message}`);
          // Error logging is handled within the API implementation or catch block
        } finally {
          // Hide loading indicator and re-enable button
          loadingDiv.classList.add('hidden');
          generateBtn.disabled = false;
          generateBtn.textContent = 'ç”Ÿæˆå›¾åƒ';
        }
      });

      // Display results in the results area
      function displayResults(images) {
        resultsDiv.innerHTML = ''; // Clear existing results
        images.forEach((image, index) => {
          const container = document.createElement('div');
          container.className = 'image-container slide-in-right'; // Add animation
          container.style.animationDelay = `${index * 0.1}s`; // Stagger animation

          const imgElement = document.createElement('img');
          imgElement.src = image.url;
          imgElement.alt = `ç”Ÿæˆçš„å›¾ç‰‡ ${index + 1}`;
          imgElement.className = 'w-full h-auto object-cover rounded-lg';
          imgElement.loading = 'lazy';
          imgElement.setAttribute('data-original', image.url); // For viewer.js

          // Add download button
          const downloadBtn = document.createElement('a');
          downloadBtn.href = image.url;
          downloadBtn.download = `fal_generated_${Date.now()}_${index}.png`; // Suggest filename
          downloadBtn.className = 'absolute top-2 right-2 bg-black/50 text-white p-1.5 rounded-full hover:bg-black/70 transition-colors text-xs';
          downloadBtn.innerHTML = 'â¬‡ï¸'; // Download icon
          downloadBtn.title = 'ä¸‹è½½å›¾ç‰‡';

          container.appendChild(imgElement);
          container.appendChild(downloadBtn);
          resultsDiv.appendChild(container);
        });

        // Re-initialize results image viewer
        setTimeout(() => {
          initializeViewers();
        }, 500);
      }

      // Display error messages
      function showError(message) {
        errorMessageDiv.textContent = message;
        errorMessageDiv.classList.remove('hidden');
        errorMessageDiv.classList.add('fade-in'); // Add fade-in effect
      }

      // NOTE: addLog and clearLogs are now defined globally above.

      // ä¿å­˜ç”¨æˆ·è®¾ç½®åˆ° localStorage
      function saveUserSettings() {
        const settings = {
          model: modelSelect.value,
          customModel: customModelInput.value,
          imageSize: imageSizeSelect.value,
          customWidth: customWidthInput.value,
          customHeight: customHeightInput.value,
          numImages: numImagesInput.value,
          numInferenceSteps: numInferenceStepsInput.value,
          guidanceScale: guidanceScaleInput.value,
          rawMode: rawModeInput.checked, // ä¿å­˜è‡ªç„¶æ¨¡å¼è®¾ç½®
          syncMode: syncModeInput.checked,
          enableSafetyChecker: enableSafetyCheckerInput.checked
        };
        localStorage.setItem('falUserSettings', JSON.stringify(settings));
        console.log('Settings saved:', settings);
      }

      // åŠ è½½ç”¨æˆ·è®¾ç½®
      function loadUserSettings() {
        try {
          const settings = JSON.parse(localStorage.getItem('falUserSettings'));
          if (!settings) return;
          
          console.log('Loading saved settings:', settings);
          
          // æ¢å¤é€‰æ‹©çš„æ¨¡å‹
          if (settings.model) {
            modelSelect.value = settings.model;
            if (settings.model === 'custom' && settings.customModel) {
              customModelInput.value = settings.customModel;
              customModelInput.classList.add('visible');
            }
          }
          
          // æ¢å¤å›¾åƒå°ºå¯¸è®¾ç½®
          if (settings.imageSize) {
            imageSizeSelect.value = settings.imageSize;
            if (settings.imageSize === 'custom') {
              const customSizeContainer = document.getElementById('customSizeContainer');
              customSizeContainer.classList.remove('hidden');
              
              if (settings.customWidth) customWidthInput.value = settings.customWidth;
              if (settings.customHeight) customHeightInput.value = settings.customHeight;
            }
          }
          
          // æ¢å¤å…¶ä»–æ•°å€¼è®¾ç½®
          if (settings.numImages) numImagesInput.value = settings.numImages;
          if (settings.numInferenceSteps) {
            numInferenceStepsInput.value = settings.numInferenceSteps;
            document.getElementById('numInferenceStepsValue').textContent = settings.numInferenceSteps;
          }
          if (settings.guidanceScale) {
            guidanceScaleInput.value = settings.guidanceScale;
            document.getElementById('guidanceScaleValue').textContent = settings.guidanceScale;
          }
          
          // æ¢å¤å¼€å…³çŠ¶æ€
          if (settings.rawMode !== undefined) rawModeInput.checked = settings.rawMode;
          if (settings.syncMode !== undefined) syncModeInput.checked = settings.syncMode;
          if (settings.enableSafetyChecker !== undefined) enableSafetyCheckerInput.checked = settings.enableSafetyChecker;
          
        } catch (error) {
          console.error('Error loading user settings:', error);
        }
      }

      // ç›‘å¬è®¾ç½®å˜åŒ–
      function setupSettingsListeners() {
        const settingsElements = [
          modelSelect, customModelInput, imageSizeSelect, customWidthInput, 
          customHeightInput, numImagesInput, numInferenceStepsInput, 
          guidanceScaleInput, rawModeInput, syncModeInput, enableSafetyCheckerInput
        ];
        
        settingsElements.forEach(element => {
          element.addEventListener('change', saveUserSettings);
        });
      }
    } // End of initializeFalApp

  </script>
</body>
</html>
